# Gradle memory usage

Данный пример показывает, как используется память при включенном кэше конфигурации на `Gradle 8.10`.

Проект состоит из трёх пустых java-модулей и не содержит include-билдов:
- java-module-01
- java-module-02
- java-module-03

В каждом модуле зарегистрирована таска `someTask`, которая на вход принимает _тяжёлый_ объект в **100** МБ
и условное время выполнения задачи (в первом модулей **1** секунда, во втором - **5**, в третьем - **30** секунд).
Объект на 100 МБ нужен, чтобы на графиках наглядней выделялись моменты выделения и освобождения памяти.

## Эксперимент

Запускаем задачу `someTask` во всех модулях сразу командой:
```shell
./gradlew someTask
```

Снимаем dump памяти в момент, когда в первых двух модулях задачи закончили выполняться, а в последнем ещё нет:

![console](docs/img/console.png)

Получаем такую картину по памяти:

![heap](docs/img/heap.png)

Вначале графика видно выделение **300** МБ памяти во время вычисления и сохранения кэша конфигурации.
Это наши "тяжёлые" объекты для каждой задачи `someTask`.

Потом мы видим как выделилось ещё **300** МБ. Это также наши "_тяжёлые_" объекты,
но на этот раз прочитанные из сохранённого кэша конфигурации.
То есть Gradle в рамках одной сборки вычисляет кэш конфигурации, сохраняет его и заново читает, поэтому потребовалось
повторное выделение памяти.

Далее видим, что во время снятия dump'а памяти принудительно вызывается сборщик мусора,
и ненужные объекты в **300** МБ удаляются. Значит, в данном случае повторное выделение памяти не так страшно.
В этом можно убедиться, если ограничить память для Gradle так, чтобы ему не хватило на повторное выделение памяти,
например, до 512 МБ, тогда, перед чтением из кэша, сначала освободятся ненужные 300 МБ.

Такая ситуация происходит, когда у нас включен кэш конфигурации, но самого кэша нет.
Если же кэш есть, то он просто прочитается один раз, и повторного выделения памяти не будет:

![heap-cc-reused](docs/img/heap_cc_reused.png)

Однако, на обоих графиках видна другая проблема. Задачи в первых двух модулях закончили своё выполнение,
но входные данные для них продолжают удерживаться в памяти до самого завершения сборки.
Такая же картина будет, если выключить кэш конфигурации, поэтому к нему она не относится.

В dump'е мы видим 3 наших "тяжёлых" объекта:

![objects](docs/img/objects.png)

## Итог

- Если кэш конфигурации включен, но самого кэша нет, произойдёт повторное выделение памяти, но это не страшно,
потому что старые объекты доступны для удаления;
- Если кэш конфигурации включен, и есть актуальный кэш, повторного выделения памяти не будет;
- Gradle удерживает в памяти входные данные для задач, даже после их выполнения, но к кэшу конфигурации это не имеет
отношения.
